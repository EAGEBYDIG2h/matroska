package matroska

import (
	"unsafe"
)

// #include <stdlib.h>
// #include "MatroskaParser.h"
// #include "typehelper.h"
import "C"

// Most of this files is autogenerated.
//
// Contains tedious and gross helper functions to convert from
// MatroskaParser's annoying C types into native Go types..

func convertTrackInfo(ci *C.TrackInfo) *TrackInfo {
	i := &TrackInfo{
		Number:             uint8(ci.Number),
		Type:               uint8(ci.Type),
		TrackOverlay:       uint8(ci.TrackOverlay),
		UID:                uint64(ci.UID),
		MinCache:           uint64(ci.MinCache),
		MaxCache:           uint64(ci.MaxCache),
		DefaultDuration:    uint64(ci.DefaultDuration),
		CodecDelay:         uint64(ci.CodecDelay),
		SeekPreRoll:        uint64(ci.SeekPreRoll),
		TimecodeScale:      float64(ci.TimecodeScale),
		CompMethod:         uint32(ci.CompMethod),
		MaxBlockAdditionID: uint32(ci.MaxBlockAdditionID),
		Name:               C.GoString(ci.Name),
		Language:           string(C.GoBytes(unsafe.Pointer(&(ci.Language[0])), 4)),
		CodecID:            C.GoString(ci.CodecID),
		Enabled:            C.tEnabled(ci) == 1,
		Default:            C.tDefault(ci) == 1,
		Forced:             C.tForced(ci) == 1,
		Lacing:             C.tLacing(ci) == 1,
		DecodeAll:          C.tDecodeAll(ci) == 1,
		CompEnabled:        C.tCompEnabled(ci) == 1,
	}

	if ci.CodecPrivateSize != 0 {
		i.CodecPrivate = C.GoBytes(unsafe.Pointer(ci.CodecPrivate), C.int(ci.CodecPrivateSize))
	}

	if ci.CompMethodPrivateSize != 0 {
		i.CompMethodPrivate = C.GoBytes(unsafe.Pointer(ci.CompMethodPrivate), C.int(ci.CompMethodPrivateSize))
	}

	switch i.Type {
	case TypeVideo:
		i.Video.StereoMode = uint8(C.tvStereoMode(ci))
		i.Video.DisplayUnit = uint8(C.tvDisplayUnit(ci))
		i.Video.AspectRatioType = uint8(C.tvAspectRatioType(ci))
		i.Video.PixelWidth = uint32(C.tvPixelWidth(ci))
		i.Video.PixelHeight = uint32(C.tvPixelHeight(ci))
		i.Video.DisplayWidth = uint32(C.tvDisplayWidth(ci))
		i.Video.DisplayHeight = uint32(C.tvDisplayHeight(ci))
		i.Video.CropL = uint32(C.tvCropL(ci))
		i.Video.CropT = uint32(C.tvCropT(ci))
		i.Video.CropR = uint32(C.tvCropR(ci))
		i.Video.CropB = uint32(C.tvCropB(ci))
		i.Video.ColourSpace = uint32(C.tvColourSpace(ci))
		i.Video.GammaValue = float64(C.tvGammaValue(ci))
		i.Video.Colour.MatrixCoefficients = uint32(C.tcMatrixCoefficients(ci))
		i.Video.Colour.BitsPerChannel = uint32(C.tcBitsPerChannel(ci))
		i.Video.Colour.ChromaSubsamplingHorz = uint32(C.tcChromaSubsamplingHorz(ci))
		i.Video.Colour.ChromaSubsamplingVert = uint32(C.tcChromaSubsamplingVert(ci))
		i.Video.Colour.CbSubsamplingHorz = uint32(C.tcCbSubsamplingHorz(ci))
		i.Video.Colour.CbSubsamplingVert = uint32(C.tcCbSubsamplingVert(ci))
		i.Video.Colour.ChromaSitingHorz = uint32(C.tcChromaSitingHorz(ci))
		i.Video.Colour.ChromaSitingVert = uint32(C.tcChromaSitingVert(ci))
		i.Video.Colour.Range = uint32(C.tcRange(ci))
		i.Video.Colour.TransferCharacteristics = uint32(C.tcTransferCharacteristics(ci))
		i.Video.Colour.Primaries = uint32(C.tcPrimaries(ci))
		i.Video.Colour.MaxCLL = uint32(C.tcMaxCLL(ci))
		i.Video.Colour.MaxFALL = uint32(C.tcMaxFALL(ci))
		i.Video.Colour.MasteringMetadata.PrimaryRChromaticityX = float32(C.tmmPrimaryRChromaticityX(ci))
		i.Video.Colour.MasteringMetadata.PrimaryRChromaticityY = float32(C.tmmPrimaryRChromaticityY(ci))
		i.Video.Colour.MasteringMetadata.PrimaryGChromaticityX = float32(C.tmmPrimaryGChromaticityX(ci))
		i.Video.Colour.MasteringMetadata.PrimaryGChromaticityY = float32(C.tmmPrimaryGChromaticityY(ci))
		i.Video.Colour.MasteringMetadata.PrimaryBChromaticityX = float32(C.tmmPrimaryBChromaticityX(ci))
		i.Video.Colour.MasteringMetadata.PrimaryBChromaticityY = float32(C.tmmPrimaryBChromaticityY(ci))
		i.Video.Colour.MasteringMetadata.WhitePointChromaticityX = float32(C.tmmWhitePointChromaticityX(ci))
		i.Video.Colour.MasteringMetadata.WhitePointChromaticityY = float32(C.tmmWhitePointChromaticityY(ci))
		i.Video.Colour.MasteringMetadata.LuminanceMax = float32(C.tmmLuminanceMax(ci))
		i.Video.Colour.MasteringMetadata.LuminanceMin = float32(C.tmmLuminanceMin(ci))
		i.Video.Interlaced = C.tvInterlaced(ci) == 1
	case TypeAudio:
		i.Audio.SamplingFreq = float64(C.taSamplingFreq(ci))
		i.Audio.OutputSamplingFreq = float64(C.taOutputSamplingFreq(ci))
		i.Audio.Channels = uint8(C.taChannels(ci))
		i.Audio.BitDepth = uint8(C.taBitDepth(ci))
	default:
	}

	return i
}

func convertSegmentInfo(ci *C.SegmentInfo) *SegmentInfo {
	i := &SegmentInfo{
		Filename:      string(C.GoString(ci.Filename)),
		PrevFilename:  string(C.GoString(ci.PrevFilename)),
		NextFilename:  string(C.GoString(ci.NextFilename)),
		Title:         string(C.GoString(ci.Title)),
		MuxingApp:     string(C.GoString(ci.MuxingApp)),
		WritingApp:    string(C.GoString(ci.WritingApp)),
		TimecodeScale: uint64(ci.TimecodeScale),
		Duration:      uint64(ci.Duration),
		DateUTC:       int64(ci.DateUTC),
		DateUTCValid:  ci.DateUTCValid != 0,
	}

	for n := 0; n < 16; n++ {
		i.UID[n] = byte(ci.UID[n])
		i.PrevUID[n] = byte(ci.PrevUID[n])
		i.NextUID[n] = byte(ci.NextUID[n])
	}

	return i
}

func convertAttachment(ca *C.Attachment) *Attachment {
	return &Attachment{
		Position:    uint64(ca.Position),
		Length:      uint64(ca.Length),
		UID:         uint64(ca.UID),
		Name:        C.GoString(ca.Name),
		Description: C.GoString(ca.Description),
		MimeType:    C.GoString(ca.MimeType),
	}
}

func convertPartialChapter(ch *C.Chapter) *Chapter {
	ret := &Chapter{
		UID:     uint64(ch.UID),
		Start:   uint64(ch.Start),
		End:     uint64(ch.End),
		Hidden:  C.chHidden(ch) == 1,
		Enabled: C.chEnabled(ch) == 1,
		Default: C.chDefault(ch) == 1,
		Ordered: C.chOrdered(ch) == 1,
	}

	for i := 0; i < 16; i++ {
		ret.SegmentUID[i] = byte(ch.SegmentUID[i])
	}

	return ret
}

func convertChapterDisplay(cd *C.struct_ChapterDisplay) ChapterDisplay {
	return ChapterDisplay{
		String:   C.GoString(cd.String),
		Language: string(C.GoBytes(unsafe.Pointer(&(cd.Language[0])), 4)),
		Country:  string(C.GoBytes(unsafe.Pointer(&(cd.Country[0])), 4)),
	}
}

func convertPartialChapterProcess(cp *C.struct_ChapterProcess) ChapterProcess {
	ret := ChapterProcess{
		CodecID: uint32(cp.CodecID),
	}

	if cp.CodecPrivateLength != 0 {
		ret.CodecPrivate = C.GoBytes(unsafe.Pointer(cp.CodecPrivate), C.int(cp.CodecPrivateLength))
	}

	return ret
}

func convertChapterCommand(cc *C.struct_ChapterCommand) ChapterCommand {
	ret := ChapterCommand{
		Time: uint32(cc.Time),
	}

	if cc.CommandLength != 0 {
		ret.Command = C.GoBytes(unsafe.Pointer(cc.Command), C.int(cc.CommandLength))
	}

	return ret
}

func convertTarget(t *C.struct_Target) Target {
	return Target{
		UID:  uint64(t.UID),
		Type: uint32(t.Type),
	}
}

func convertSimpleTag(s *C.struct_SimpleTag) SimpleTag {
	return SimpleTag{
		Name:     C.GoString(s.Name),
		Value:    C.GoString(s.Value),
		Language: string(C.GoBytes(unsafe.Pointer(&(s.Language[0])), 4)),
		Default:  C.stDefault(s) == 1,
	}
}

func convertCue(cc *C.Cue) *Cue {
	return &Cue{
		Time:             uint64(cc.Time),
		Duration:         uint64(cc.Duration),
		Position:         uint64(cc.Position),
		RelativePosition: uint64(cc.RelativePosition),
		Block:            uint64(cc.Block),
		Track:            uint8(cc.Track),
	}
}
